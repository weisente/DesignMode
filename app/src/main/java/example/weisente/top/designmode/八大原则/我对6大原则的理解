单一责任原则：Single Responsibility Principle
定义：就一个类而言，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。
反例：请求和缓存完全写到了一堆
例如做一个下载的工具 我们需要把下载和缓存进行分开

开闭原则：Open Close Principle
软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭（关闭）的。
当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。
具体的实现  例如需要切换http引擎的时候，我们需要把http引擎写一个接口

里氏替换原则：Liskov Substitution Principle
只要父类能出现的地方子类就可以出现，主要体现就是实现和继承（意思是不要写死 多写接口方便替换）

依赖倒置原则：Dependence Inversion Principle
指代了一种特定的解耦形式，高层模块不依赖低层次模块的细节，说白了高层次就是不依赖细节而是依赖抽象。
具体做法是越是高级，越是抽象

接口隔离原则：Interface Segregation Principle
类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。
接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署，让客户端依赖的接口尽可能地小。（接口拆分，单接口）

迪米特原则 Law of Demeter  Least Knowledge Principle
一个对象应该对其他对象有最少的了解，调用者也是比较关注。

在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关。
遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。
但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。
为什么会这样  因为一个类里面不会拥有其他的实体类，但是需要调用其他类的方法，就必须生成一个方法，所以方法很多





